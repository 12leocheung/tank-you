<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TANK ROYALE</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#000; display:flex; justify-content:center; align-items:center; height:100vh; font-family:'Courier New',monospace; overflow:hidden; cursor:none; }
#gc { position:relative; }
canvas { display:block; }
#ui { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
#hud { position:absolute; top:16px; left:16px; color:#fff; font-size:12px; letter-spacing:2px; }
#hud .label { color:#888; font-size:9px; letter-spacing:3px; margin-bottom:2px; }
#barWrap { width:220px; height:7px; background:#222; border:1px solid #333; margin-bottom:8px; }
#hpFill  { height:100%; background:#fff; transition:width .15s; }
#xpBarWrap { width:220px; height:4px; background:#1a1a1a; border:1px solid #2a2a2a; margin-bottom:3px; }
#xpFill { height:100%; background:#555; transition:width .3s; }
#classTag { font-size:12px; letter-spacing:3px; color:#ccc; margin-bottom:5px; }
#aliveCount { font-size:18px; letter-spacing:2px; margin-bottom:10px; }
#ammoBar { display:flex; align-items:center; gap:3px; margin-top:4px; }
.ammoPip { width:8px; height:13px; background:#fff; }
.ammoPip.empty { background:#222; }
#minimap { position:absolute; bottom:16px; right:16px; border:1px solid #333; background:rgba(0,0,0,.85); }
#kf { position:absolute; top:16px; right:16px; text-align:right; font-size:11px; letter-spacing:1px; max-width:280px; }
.ke { color:#bbb; margin:2px 0; transition:opacity .8s; }
#zoneInfo { position:absolute; top:16px; left:50%; transform:translateX(-50%); color:#fff; font-size:11px; letter-spacing:3px; text-align:center; pointer-events:none; }
#upgradePanel { position:absolute; bottom:70px; left:50%; transform:translateX(-50%); display:none; pointer-events:all; background:rgba(0,0,0,.95); border:1px solid #444; padding:18px 24px; min-width:520px; }
#upgradePanel h3 { letter-spacing:4px; font-size:12px; color:#fff; margin-bottom:14px; text-align:center; }
#upgradeBtns { display:flex; gap:10px; justify-content:center; }
.upBtn { background:none; border:1px solid #444; color:#bbb; font-family:'Courier New',monospace; font-size:11px; letter-spacing:1px; padding:12px 14px; cursor:pointer; transition:all .15s; width:148px; text-align:left; }
.upBtn:hover { border-color:#fff; color:#fff; background:rgba(255,255,255,.04); }
.upBtn .upName { font-size:13px; color:#fff; margin-bottom:5px; letter-spacing:2px; }
.upBtn .upDesc { font-size:9px; color:#555; letter-spacing:1px; line-height:1.6; }
.upBtn .upLvl { font-size:9px; color:#444; margin-top:5px; }

/* Screens */
#menu,#deathScreen,#winScreen,#classScreen,#lobbyScreen,#onlineScreen { position:absolute; top:0; left:0; width:100%; height:100%; background:#000; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#fff; pointer-events:all; }
#menu h1 { font-size:62px; letter-spacing:14px; font-weight:900; margin-bottom:4px; }
#menu .sub { letter-spacing:8px; font-size:12px; color:#444; margin-bottom:10px; }
#statsRow { font-size:11px; letter-spacing:2px; color:#555; margin-bottom:8px; }
#rankRow { font-size:14px; letter-spacing:4px; color:#888; margin-bottom:36px; border:1px solid #222; padding:8px 24px; }
.menuBtn { background:none; border:1px solid #333; color:#888; font-family:'Courier New',monospace; font-size:14px; letter-spacing:4px; padding:12px 40px; margin:5px; cursor:pointer; transition:all .15s; }
.menuBtn:hover { border-color:#fff; color:#fff; }
.menuBtn.primary { border-color:#666; color:#ddd; }
.menuBtn.danger { border-color:#444; color:#666; }
#deathScreen h2,#winScreen h2 { font-size:52px; letter-spacing:8px; margin-bottom:10px; }
#endStats,#endStats2 { font-size:12px; letter-spacing:2px; color:#666; margin-bottom:24px; text-align:center; line-height:2.2; }
#classScreen h2 { font-size:34px; letter-spacing:8px; margin-bottom:4px; }
#classScreen .sub { color:#444; letter-spacing:4px; font-size:11px; margin-bottom:32px; }
#classGrid { display:flex; gap:12px; margin-bottom:28px; }
.classCard { border:1px solid #222; padding:18px 14px; width:148px; cursor:pointer; transition:all .2s; text-align:center; }
.classCard:hover,.classCard.selected { border-color:#fff; background:rgba(255,255,255,.03); }
.classCard .cname { font-size:12px; letter-spacing:3px; margin-bottom:6px; color:#fff; }
.classCard .cicon { font-size:28px; margin-bottom:8px; }
.classCard .cstat { font-size:8px; color:#555; letter-spacing:1px; line-height:1.8; text-align:left; }
.classCard .cbadge { font-size:8px; color:#666; letter-spacing:1px; margin-top:6px; border-top:1px solid #1a1a1a; padding-top:6px; }
#rankBadge { position:absolute; bottom:16px; left:16px; font-size:10px; letter-spacing:2px; color:#555; border:1px solid #222; padding:5px 10px; }
.xpFloat { position:absolute; font-size:12px; letter-spacing:2px; color:#fff; pointer-events:none; animation:xpRise .9s forwards; font-family:'Courier New',monospace; }
@keyframes xpRise { 0%{opacity:1;transform:translateY(0)} 100%{opacity:0;transform:translateY(-45px)} }
#menuCvs { position:absolute; top:0; left:0; pointer-events:none; z-index:9999; }

/* Lobby screen */
#lobbyScreen h2 { font-size:36px; letter-spacing:8px; margin-bottom:4px; }
#lobbyScreen .sub { color:#444; font-size:11px; letter-spacing:4px; margin-bottom:28px; }
#lobbyCode { font-size:52px; letter-spacing:16px; font-weight:900; color:#fff; margin-bottom:6px; font-family:'Courier New',monospace; }
#lobbyCodeLabel { font-size:10px; letter-spacing:3px; color:#444; margin-bottom:28px; }
#countdown { font-size:22px; letter-spacing:6px; color:#888; margin-bottom:20px; }
#playerList { display:flex; flex-direction:column; gap:6px; margin-bottom:24px; min-height:80px; min-width:300px; }
.playerEntry { font-size:11px; letter-spacing:2px; border:1px solid #222; padding:6px 12px; display:flex; justify-content:space-between; align-items:center; }
.playerEntry .pname { color:#ccc; }
.playerEntry .pclass { color:#555; font-size:9px; letter-spacing:3px; }
.playerEntry.isBot { opacity:0.4; }
#joinInput { background:none; border:1px solid #444; color:#fff; font-family:'Courier New',monospace; font-size:22px; letter-spacing:8px; padding:10px 18px; text-align:center; text-transform:uppercase; width:200px; margin-bottom:8px; }
#joinInput:focus { outline:none; border-color:#fff; }
#joinInput::placeholder { color:#333; font-size:14px; letter-spacing:4px; }
#lobbyStatus { font-size:11px; letter-spacing:2px; color:#555; min-height:18px; margin-bottom:10px; }
#onlineOptions { display:flex; flex-direction:column; align-items:center; gap:6px; }
.divider { width:200px; height:1px; background:#1a1a1a; margin:10px 0; }
#mqttStatus { position:absolute; bottom:50px; left:50%; transform:translateX(-50%); font-size:9px; letter-spacing:2px; color:#333; }

/* ── Rank Card (menu) ── */
#rankCard { text-align:center; margin-bottom:32px; padding:18px 36px; border:1px solid #222; min-width:280px; }
#rankTierLabel { font-size:28px; letter-spacing:6px; font-weight:900; margin-bottom:2px; }
#rankRpLabel { font-size:11px; letter-spacing:3px; color:#555; margin-bottom:10px; }
#rankBarOuter { width:100%; height:5px; background:#1a1a1a; border-radius:2px; overflow:hidden; margin-bottom:4px; }
#rankBarFill { height:100%; background:#fff; transition:width .4s; border-radius:2px; }
#rankBarSub { font-size:9px; letter-spacing:2px; color:#444; }

/* ── RP result overlay (shown after game before going back) ── */
#rpResult { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.95); border:1px solid #333; padding:16px 28px; text-align:center; min-width:320px; pointer-events:none; }
#rpResult .rpTitle { font-size:10px; letter-spacing:4px; color:#555; margin-bottom:8px; }
#rpResult .rpRows { font-size:12px; letter-spacing:2px; line-height:2.2; }
#rpResult .rpChange { font-size:22px; letter-spacing:4px; font-weight:900; margin-top:6px; }
#rpResult .rpChange.up { color:#fff; }
#rpResult .rpChange.down { color:#666; }
#rpResult .rpNew { font-size:10px; letter-spacing:3px; color:#666; margin-top:4px; }
#rpResult .rpBarWrap { width:100%; height:4px; background:#1a1a1a; margin-top:8px; }
#rpResult .rpBarFill { height:100%; background:#fff; transition:width 1s; }

/* ── In-game rank badge ── */
#rankBadge { position:absolute; bottom:16px; left:16px; font-size:10px; letter-spacing:2px; color:#555; border:1px solid #1e1e1e; padding:5px 10px; }
</style>
</head>
<body>
<div id="gc">
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div id="hud">
      <div id="aliveCount">■ 20 ALIVE</div>
      <div class="label">HP</div>
      <div id="barWrap"><div id="hpFill" style="width:100%"></div></div>
      <div id="classTag">WARRIOR ◉</div>
      <div class="label">XP · <span id="lvlLabel">LV 1</span></div>
      <div id="xpBarWrap"><div id="xpFill" style="width:0%"></div></div>
      <div id="ammoBar"></div>
    </div>
    <div id="zoneInfo"></div>
    <canvas id="minimap" width="160" height="160"></canvas>
    <div id="kf"></div>
    <div id="rankBadge">UNRANKED</div>
    <div id="upgradePanel">
      <h3>▲ LEVEL UP — CHOOSE UPGRADE</h3>
      <div id="upgradeBtns"></div>
    </div>
    <div id="deathScreen" style="display:none">
      <h2>DESTROYED</h2>
      <div id="endStats"></div>
      <div id="rpResult" style="position:relative;bottom:auto;left:auto;transform:none;margin-bottom:16px;"></div>
      <button class="menuBtn" onclick="showMenu()">MAIN MENU</button>
      <button class="menuBtn primary" onclick="quickRestart()">PLAY AGAIN</button>
    </div>
    <div id="winScreen" style="display:none">
      <h2>VICTORY</h2>
      <div id="endStats2"></div>
      <div id="rpResult2" style="position:relative;bottom:auto;left:auto;transform:none;margin-bottom:16px;background:rgba(0,0,0,.95);border:1px solid #333;padding:16px 28px;text-align:center;min-width:320px;"></div>
      <button class="menuBtn" onclick="showMenu()">MAIN MENU</button>
      <button class="menuBtn primary" onclick="quickRestart()">PLAY AGAIN</button>
    </div>
  </div>
  <canvas id="menuCvs"></canvas>

  <!-- MAIN MENU -->
  <div id="menu">
    <h1>TANK ROYALE</h1>
    <div class="sub">LAST TANK STANDING</div>
    <div id="rankCard">
      <div id="rankTierLabel">BRONZE III</div>
      <div id="rankRpLabel">0 RP</div>
      <div id="rankBarOuter"><div id="rankBarFill"></div></div>
      <div id="rankBarSub"></div>
    </div>
    <div id="statsRow"></div>
    <button class="menuBtn primary" onclick="showClassSelect('bot')">BOT MODE</button>
    <button class="menuBtn" onclick="showOnlineOptions()">RANKED ONLINE</button>
    <div style="color:#2a2a2a;font-size:9px;letter-spacing:2px;margin-top:18px;">WASD · MOUSE AIM · LMB SHOOT · SPACE ABILITY</div>
  </div>

  <!-- ONLINE OPTIONS -->
  <div id="onlineScreen" style="display:none; position:absolute;top:0;left:0;width:100%;height:100%;background:#000;flex-direction:column;justify-content:center;align-items:center;color:#fff;pointer-events:all;">
    <h2 style="font-size:32px;letter-spacing:8px;margin-bottom:6px;">ONLINE MODE</h2>
    <div style="color:#444;font-size:11px;letter-spacing:4px;margin-bottom:36px;">CREATE OR JOIN A LOBBY</div>
    <button class="menuBtn primary" onclick="showClassSelect('online_create')">CREATE LOBBY</button>
    <div class="divider"></div>
    <div style="color:#555;font-size:10px;letter-spacing:3px;margin-bottom:10px;">JOIN WITH CODE</div>
    <input id="joinInput" type="text" maxlength="4" placeholder="XXXX" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z0-9]/g,'')">
    <div id="joinStatus" style="font-size:10px;letter-spacing:2px;color:#555;height:16px;margin-bottom:8px;"></div>
    <button class="menuBtn" onclick="doJoinLobby()">JOIN →</button>
    <button class="menuBtn danger" onclick="showMenu()" style="margin-top:12px;font-size:10px;padding:7px 22px;">← BACK</button>
    <div id="mqttStatus">CONNECTING...</div>
  </div>

  <!-- LOBBY WAITING ROOM -->
  <div id="lobbyScreen" style="display:none;">
    <h2>LOBBY</h2>
    <div class="sub">SHARE CODE · WAIT FOR PLAYERS · BOTS FILL AT ZERO</div>
    <div id="lobbyCode">----</div>
    <div id="lobbyCodeLabel">LOBBY CODE — CLICK TO COPY</div>
    <div id="countdown">60s</div>
    <div id="playerList"></div>
    <div id="lobbyStatus"></div>
    <button class="menuBtn danger" onclick="leaveLobby()">LEAVE LOBBY</button>
  </div>

  <!-- CLASS SELECT -->
  <div id="classScreen" style="display:none">
    <h2>SELECT CLASS</h2>
    <div class="sub">CHOOSE YOUR TANK</div>
    <div id="classGrid"></div>
    <button class="menuBtn primary" onclick="confirmClass()">DEPLOY →</button>
    <button class="menuBtn" onclick="goBackFromClass()" style="font-size:10px;padding:7px 22px;margin-top:4px;">← BACK</button>
  </div>
</div>

<script>
'use strict';

// ═══════════════════════════════════════════
// AUDIO
// ═══════════════════════════════════════════
const AC = new (window.AudioContext || window.webkitAudioContext)();
function nbuf(dur) {
  const sr=AC.sampleRate, b=AC.createBuffer(1,Math.ceil(sr*dur),sr), d=b.getChannelData(0);
  for (let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return b;
}
function playShot(pm=1) {
  if (AC.state==='suspended') AC.resume();
  const t=AC.currentTime;
  const m=AC.createDynamicsCompressor(); m.threshold.value=-6; m.ratio.value=20; m.attack.value=0.001; m.release.value=0.1; m.connect(AC.destination);
  const F=fn=>{try{fn();}catch(e){}};
  F(()=>{const s=AC.createBufferSource();s.buffer=nbuf(0.03);const f=AC.createBiquadFilter();f.type='highpass';f.frequency.value=3000*pm;const g=AC.createGain();g.gain.setValueAtTime(3.5,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.025);s.connect(f);f.connect(g);g.connect(m);s.start(t);s.stop(t+0.03);});
  F(()=>{const s=AC.createBufferSource();s.buffer=nbuf(0.12);const f=AC.createBiquadFilter();f.type='bandpass';f.frequency.setValueAtTime(2200*pm,t);f.frequency.exponentialRampToValueAtTime(600*pm,t+0.1);f.Q.value=1.2;const w=AC.createWaveShaper();const c=new Float32Array(512);for(let i=0;i<512;i++){const x=(i*2)/512-1;c[i]=(Math.PI+300)*x/(Math.PI+300*Math.abs(x));}w.curve=c;const g=AC.createGain();g.gain.setValueAtTime(2.8,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.12);s.connect(f);f.connect(w);w.connect(g);g.connect(m);s.start(t);s.stop(t+0.13);});
  F(()=>{const o=AC.createOscillator();o.type='sine';o.frequency.setValueAtTime(220/pm,t);o.frequency.exponentialRampToValueAtTime(28/pm,t+0.18);const g=AC.createGain();g.gain.setValueAtTime(2.2,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);o.connect(g);g.connect(m);o.start(t);o.stop(t+0.22);});
  F(()=>{const s=AC.createBufferSource();s.buffer=nbuf(0.3);const f=AC.createBiquadFilter();f.type='lowpass';f.frequency.setValueAtTime(180/pm,t);f.frequency.exponentialRampToValueAtTime(40/pm,t+0.25);const g=AC.createGain();g.gain.setValueAtTime(1.6,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);s.connect(f);f.connect(g);g.connect(m);s.start(t);s.stop(t+0.32);});
  F(()=>{const s=AC.createBufferSource();s.buffer=nbuf(0.65);const b1=AC.createBiquadFilter();b1.type='bandpass';b1.frequency.setValueAtTime(900*pm,t+0.05);b1.frequency.exponentialRampToValueAtTime(200*pm,t+0.65);b1.Q.value=8;const g=AC.createGain();g.gain.setValueAtTime(0,t);g.gain.linearRampToValueAtTime(0.9,t+0.05);g.gain.exponentialRampToValueAtTime(0.001,t+0.7);const dl=AC.createDelay(0.5);dl.delayTime.value=0.04;const fb=AC.createGain();fb.gain.value=0.45;s.connect(b1);b1.connect(g);g.connect(dl);dl.connect(fb);fb.connect(dl);g.connect(m);dl.connect(m);s.start(t+0.04);s.stop(t+0.72);});
  F(()=>{const s=AC.createBufferSource();s.buffer=nbuf(0.8);const f=AC.createBiquadFilter();f.type='bandpass';f.frequency.setValueAtTime(500*pm,t+0.3);f.frequency.exponentialRampToValueAtTime(100*pm,t+1.0);f.Q.value=3;const g=AC.createGain();g.gain.setValueAtTime(0,t+0.28);g.gain.linearRampToValueAtTime(0.35,t+0.35);g.gain.exponentialRampToValueAtTime(0.001,t+1.1);s.connect(f);f.connect(g);g.connect(m);s.start(t+0.28);s.stop(t+1.15);});
}

// ═══════════════════════════════════════════
// CANVAS / CONSTANTS
// ═══════════════════════════════════════════
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniCvs = document.getElementById('minimap');
const mctx = miniCvs.getContext('2d');
const W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;
document.getElementById('gc').style.cssText = `width:${W}px;height:${H}px`;
const MAP=4000, MINI=160, MAX_P=20;

// ═══════════════════════════════════════════
// PERSISTENCE & RANKED POINTS SYSTEM
// ═══════════════════════════════════════════
const DEFAULT_SAVE = '{"rp":0,"wins":0,"kills":0,"games":0,"peakRp":0,"history":[]}';
let pd = JSON.parse(localStorage.getItem('tankroyale') || DEFAULT_SAVE);
if (pd.xp !== undefined && pd.rp === undefined) { pd.rp = pd.xp; pd.peakRp = pd.xp; pd.history = []; delete pd.xp; }
if (!pd.history) pd.history = [];
if (!pd.peakRp) pd.peakRp = pd.rp || 0;
function saveData() { localStorage.setItem('tankroyale', JSON.stringify(pd)); }

const TIERS = [
  { name:'BRONZE',   minRp:0,    divs:3, rpPerDiv:100, color:'#cd7f32' },
  { name:'SILVER',   minRp:300,  divs:3, rpPerDiv:150, color:'#b0b0b0' },
  { name:'GOLD',     minRp:750,  divs:3, rpPerDiv:200, color:'#ffd700' },
  { name:'PLATINUM', minRp:1350, divs:3, rpPerDiv:300, color:'#40e0d0' },
  { name:'DIAMOND',  minRp:2250, divs:3, rpPerDiv:400, color:'#a0d8ef' },
  { name:'MASTER',   minRp:3450, divs:1, rpPerDiv:999, color:'#ffffff' },
];

function getRankInfo(rp) {
  rp = Math.max(0, rp);
  let tierIdx = 0;
  for (let i = 0; i < TIERS.length; i++) { if (rp >= TIERS[i].minRp) tierIdx = i; }
  const tier = TIERS[tierIdx];
  const rpInTier = rp - tier.minRp;
  const div = tier.divs === 1 ? 0 : Math.min(tier.divs - 1, Math.floor(rpInTier / tier.rpPerDiv));
  const rpInDiv = tier.divs === 1 ? rpInTier : rpInTier - div * tier.rpPerDiv;
  const divLabel = tier.divs === 1 ? '' : ' ' + ['III','II','I'][div];
  const nextTier = TIERS[tierIdx + 1] || null;
  return { tier, tierIdx, div, rpInDiv, divLabel, label: tier.name + divLabel, color: tier.color,
    rpPerDiv: tier.divs === 1 ? 999 : tier.rpPerDiv, isMaster: tier.name === 'MASTER', nextTier, totalRp: rp };
}

function calcRpChange(placement, kills) {
  let base = 0;
  if      (placement === 1)  base = 50;
  else if (placement <= 3)   base = 30;
  else if (placement <= 5)   base = 20;
  else if (placement <= 10)  base = 10;
  else if (placement <= 15)  base = 0;
  else                       base = -15;
  const killBonus = Math.min(kills * 8, 40);
  const tierIdx = getRankInfo(pd.rp).tierIdx;
  const rankMult = [1, 1, 1.1, 1.2, 1.3, 1.5][tierIdx] || 1;
  const total = base >= 0 ? Math.round((base + killBonus) * rankMult) : Math.round(base * rankMult);
  return { total, base, killBonus: Math.round(killBonus), rankMult };
}

function applyRpChange(change) {
  const before = pd.rp;
  pd.rp = Math.max(0, pd.rp + change);
  if (pd.rp > (pd.peakRp || 0)) pd.peakRp = pd.rp;
  return { before, after: pd.rp, change };
}

function getPlayerRank() { return getRankInfo(pd.rp); }

// ═══════════════════════════════════════════
// TANK CLASSES
// ═══════════════════════════════════════════
const CLASSES = {
  SCOUT:   {icon:'◎',hp:70, speed:3.8,damage:18,fireRate:300,bulletSpeed:13,bulletLife:230,radius:15,barrels:1,ability:'DASH',  abilityDesc:'Burst forward',          abilityCooldown:4000, stats:{HP:'70', SPD:'★★★★★',DMG:'★★☆☆☆',FIRE:'★★★★☆'}},
  WARRIOR: {icon:'◉',hp:100,speed:2.5,damage:25,fireRate:400,bulletSpeed:10,bulletLife:200,radius:18,barrels:1,ability:'SHIELD',abilityDesc:'2s invincibility',       abilityCooldown:8000, stats:{HP:'100',SPD:'★★★☆☆',DMG:'★★★☆☆',FIRE:'★★★☆☆'}},
  HEAVY:   {icon:'⬟',hp:165,speed:1.6,damage:48,fireRate:720,bulletSpeed:8, bulletLife:155,radius:23,barrels:1,ability:'SLAM',  abilityDesc:'Shockwave nearby',       abilityCooldown:10000,stats:{HP:'165',SPD:'★★☆☆☆',DMG:'★★★★★',FIRE:'★★☆☆☆'}},
  SNIPER:  {icon:'⊕',hp:80, speed:2.2,damage:70,fireRate:950,bulletSpeed:19,bulletLife:380,radius:16,barrels:1,ability:'CLOAK', abilityDesc:'Invisible on minimap',   abilityCooldown:9000, stats:{HP:'80', SPD:'★★☆☆☆',DMG:'★★★★★',FIRE:'★★☆☆☆'}},
  TWIN:    {icon:'⊞',hp:90, speed:2.3,damage:16,fireRate:330,bulletSpeed:10,bulletLife:190,radius:17,barrels:2,ability:'BURST', abilityDesc:'6-shot rapid burst',     abilityCooldown:6000, stats:{HP:'90', SPD:'★★★☆☆',DMG:'★★★☆☆',FIRE:'★★★★☆'}},
};
const UPGRADES = [
  {id:'hp',    name:'ARMOR+',   desc:'+30 max HP\n+20 current HP',    apply:t=>{t.maxHp+=30;t.hp=Math.min(t.maxHp,t.hp+20);}},
  {id:'spd',   name:'OVERDRIVE',desc:'+15% move speed',               apply:t=>{t.speed*=1.15;}},
  {id:'dmg',   name:'WARHEAD',  desc:'+20% bullet damage',            apply:t=>{t.damage*=1.2;}},
  {id:'fire',  name:'AUTOLOAD', desc:'-15% reload (faster fire)',      apply:t=>{t.fireRate*=0.85;}},
  {id:'bspd',  name:'HYPERBOLT',desc:'+20% bullet velocity',          apply:t=>{t.bulletSpeed*=1.2;}},
  {id:'range', name:'LONGSHOT', desc:'+30% bullet range',             apply:t=>{t.bulletLife*=1.3;}},
  {id:'regen', name:'REPAIR',   desc:'Passive HP regen',              apply:t=>{t.regen=(t.regen||0)+0.05;}},
  {id:'pierce',name:'PIERCE',   desc:'Bullets pierce 1 extra target', apply:t=>{t.pierce=true;}},
  {id:'split', name:'SPLITTER', desc:'Bullets split on first hit',    apply:t=>{t.split=true;}},
  {id:'cd',    name:'COOLDOWN', desc:'-20% ability cooldown',         apply:t=>{t.abilityCooldown*=0.8;}},
  {id:'multi', name:'MULTISHOT',desc:'Fire extra bullet per shot',    apply:t=>{t.extraBarrel=true;}},
];
function xpForLevel(l) { return 60 + l*55; }

// ═══════════════════════════════════════════
// MQTT / ONLINE
// ═══════════════════════════════════════════
const MY_ID = Math.random().toString(36).slice(2,10);
let mqttClient = null;
let mqttConnected = false;
let lobbyCode = null;
let lobbyPlayers = {}; // id -> {name, className, isBot, ready}
let isLobbyHost = false;
let lobbyCountdown = 60;
let lobbyTimer = null;
let pendingMode = null;
let remoteEntities = {}; // id -> entity object for online sync
let onlineMode = false;

function genCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  return Array.from({length:4}, () => chars[Math.floor(Math.random()*chars.length)]).join('');
}

function mqttTopic(code, sub) { return `tankroyale/${code}/${sub}`; }

function initMQTT(onConnected) {
  if (mqttClient && mqttConnected) { onConnected(); return; }
  // Use EMQX public broker (free, no signup)
  const clientId = 'tr_' + MY_ID;
  mqttClient = new Paho.MQTT.Client('broker.emqx.io', 8084, '/mqtt', clientId);
  mqttClient.onConnectionLost = () => {
    mqttConnected = false;
    setStatus('CONNECTION LOST');
  };
  mqttClient.onMessageArrived = onMQTTMessage;
  mqttClient.connect({
    useSSL: true,
    timeout: 10,
    keepAliveInterval: 30,
    onSuccess: () => {
      mqttConnected = true;
      document.getElementById('mqttStatus').textContent = 'CONNECTED';
      onConnected();
    },
    onFailure: (e) => {
      mqttConnected = false;
      document.getElementById('mqttStatus').textContent = 'OFFLINE — BOT ONLY';
      setStatus('COULD NOT CONNECT. TRY BOT MODE.');
    }
  });
}

function mqttPublish(topic, payload) {
  if (!mqttClient || !mqttConnected) return;
  const msg = new Paho.MQTT.Message(JSON.stringify(payload));
  msg.destinationName = topic;
  msg.retained = false;
  try { mqttClient.send(msg); } catch(e) {}
}

function mqttSubscribe(topic) {
  if (!mqttClient || !mqttConnected) return;
  try { mqttClient.subscribe(topic); } catch(e) {}
}

function onMQTTMessage(message) {
  let data;
  try { data = JSON.parse(message.payloadString); } catch(e) { return; }
  const topic = message.destinationName;

  if (topic === mqttTopic(lobbyCode, 'join')) {
    handlePlayerJoin(data);
  } else if (topic === mqttTopic(lobbyCode, 'leave')) {
    handlePlayerLeave(data);
  } else if (topic === mqttTopic(lobbyCode, 'start')) {
    handleGameStart(data);
  } else if (topic === mqttTopic(lobbyCode, 'state')) {
    handlePlayerState(data);
  } else if (topic === mqttTopic(lobbyCode, 'event')) {
    handleGameEvent(data);
  }
}

// ═══════════════════════════════════════════
// LOBBY LOGIC
// ═══════════════════════════════════════════
function setStatus(msg) {
  const el = document.getElementById('lobbyStatus') || document.getElementById('joinStatus');
  if (el) el.textContent = msg;
}

function showOnlineOptions() {
  document.getElementById('menu').style.display = 'none';
  const s = document.getElementById('onlineScreen');
  s.style.display = 'flex';
  document.getElementById('mqttStatus').textContent = 'CONNECTING...';
  initMQTT(() => {});
}

function createLobby(clsName) {
  lobbyCode = genCode();
  isLobbyHost = true;
  lobbyPlayers = {};
  lobbyPlayers[MY_ID] = {id: MY_ID, name: pd.name || ('P_'+MY_ID.slice(0,4).toUpperCase()), className: clsName, isBot: false};
  showLobbyScreen();
  // Subscribe to lobby topics
  mqttSubscribe(mqttTopic(lobbyCode, 'join'));
  mqttSubscribe(mqttTopic(lobbyCode, 'leave'));
  mqttSubscribe(mqttTopic(lobbyCode, 'start'));
  // Announce self
  mqttPublish(mqttTopic(lobbyCode, 'join'), {id:MY_ID, name:lobbyPlayers[MY_ID].name, className:clsName, isBot:false});
  startLobbyCountdown();
}

function doJoinLobby() {
  const code = document.getElementById('joinInput').value.trim().toUpperCase();
  if (code.length !== 4) { document.getElementById('joinStatus').textContent = 'ENTER 4-CHARACTER CODE'; return; }
  if (!mqttConnected) { document.getElementById('joinStatus').textContent = 'NOT CONNECTED — TRY AGAIN'; return; }
  document.getElementById('joinStatus').textContent = 'JOINING...';
  // We need a class selected — go to class screen first
  pendingMode = 'online_join_' + code;
  document.getElementById('onlineScreen').style.display = 'none';
  document.getElementById('classScreen').style.display = 'flex';
  buildClassGrid();
}

function joinLobby(code, clsName) {
  lobbyCode = code;
  isLobbyHost = false;
  lobbyPlayers = {};
  lobbyPlayers[MY_ID] = {id: MY_ID, name: pd.name || ('P_'+MY_ID.slice(0,4).toUpperCase()), className: clsName, isBot: false};
  showLobbyScreen();
  mqttSubscribe(mqttTopic(lobbyCode, 'join'));
  mqttSubscribe(mqttTopic(lobbyCode, 'leave'));
  mqttSubscribe(mqttTopic(lobbyCode, 'start'));
  // Announce self
  mqttPublish(mqttTopic(lobbyCode, 'join'), {id:MY_ID, name:lobbyPlayers[MY_ID].name, className:clsName, isBot:false});
}

function handlePlayerJoin(data) {
  if (data.id === MY_ID) return;
  lobbyPlayers[data.id] = data;
  // If I'm host, respond with my info too so the joiner knows I'm here
  if (isLobbyHost) {
    mqttPublish(mqttTopic(lobbyCode, 'join'), {id:MY_ID, name:lobbyPlayers[MY_ID].name, className:lobbyPlayers[MY_ID].className, isBot:false});
  }
  updateLobbyUI();
}

function handlePlayerLeave(data) {
  delete lobbyPlayers[data.id];
  updateLobbyUI();
}

function handleGameStart(data) {
  // Host broadcasts the full initial setup: player slots, map seed, etc.
  if (isLobbyHost) return; // host already started
  clearInterval(lobbyTimer);
  document.getElementById('lobbyScreen').style.display = 'none';
  // data.players is the ordered list of all slots (real + bots)
  startOnlineGame(data);
}

function startLobbyCountdown() {
  lobbyCountdown = 60;
  updateLobbyUI();
  lobbyTimer = setInterval(() => {
    lobbyCountdown--;
    updateLobbyUI();
    if (lobbyCountdown <= 0) {
      clearInterval(lobbyTimer);
      if (isLobbyHost) launchOnlineLobby();
    }
  }, 1000);
}

function launchOnlineLobby() {
  // Build full player list: real players + fill bots
  const realPlayers = Object.values(lobbyPlayers).filter(p => !p.isBot);
  const allSlots = [...realPlayers];
  const ck = Object.keys(CLASSES);
  const mapSeed = Math.floor(Math.random() * 999999);
  while (allSlots.length < MAX_P) {
    allSlots.push({id: 'bot_'+allSlots.length, name:'BOT_'+Math.random().toString(36).slice(2,5).toUpperCase(), className: ck[Math.floor(Math.random()*ck.length)], isBot: true});
  }
  // Broadcast start
  mqttPublish(mqttTopic(lobbyCode, 'start'), {players: allSlots, mapSeed});
  // Subscribe to game state
  mqttSubscribe(mqttTopic(lobbyCode, 'state'));
  mqttSubscribe(mqttTopic(lobbyCode, 'event'));
  document.getElementById('lobbyScreen').style.display = 'none';
  startOnlineGame({players: allSlots, mapSeed});
}

function leaveLobby() {
  if (lobbyCode) {
    mqttPublish(mqttTopic(lobbyCode, 'leave'), {id: MY_ID});
    if (mqttClient) try { mqttClient.unsubscribe(mqttTopic(lobbyCode,'#')); } catch(e) {}
  }
  clearInterval(lobbyTimer);
  lobbyCode = null;
  showMenu();
}

function showLobbyScreen() {
  ['menu','classScreen','onlineScreen','deathScreen','winScreen'].forEach(id => {
    document.getElementById(id).style.display = 'none';
  });
  const ls = document.getElementById('lobbyScreen');
  ls.style.display = 'flex';
  document.getElementById('lobbyCode').textContent = lobbyCode;
  document.getElementById('lobbyCodeLabel').onclick = () => {
    navigator.clipboard.writeText(lobbyCode).catch(()=>{});
    document.getElementById('lobbyCodeLabel').textContent = 'COPIED!';
    setTimeout(() => document.getElementById('lobbyCodeLabel').textContent = 'LOBBY CODE — CLICK TO COPY', 1500);
  };
  updateLobbyUI();
}

function updateLobbyUI() {
  const list = document.getElementById('playerList');
  const realCount = Object.values(lobbyPlayers).filter(p=>!p.isBot).length;
  const botCount = MAX_P - realCount;
  let html = '';
  for (const p of Object.values(lobbyPlayers)) {
    if (!p.isBot) html += `<div class="playerEntry"><span class="pname">${p.name}</span><span class="pclass">${p.className}</span></div>`;
  }
  // Show bot placeholders
  for (let i=0; i<Math.min(botCount, 3); i++) html += `<div class="playerEntry isBot"><span class="pname">WAITING...</span><span class="pclass">BOT SLOT</span></div>`;
  if (botCount > 3) html += `<div class="playerEntry isBot"><span class="pname">+${botCount-3} MORE BOT SLOTS</span><span class="pclass"></span></div>`;
  list.innerHTML = html;
  const cd = document.getElementById('countdown');
  if (cd) cd.textContent = `${lobbyCountdown}s — ${realCount}/${MAX_P} PLAYERS`;
  const status = document.getElementById('lobbyStatus');
  if (status) status.textContent = isLobbyHost ? 'YOU ARE HOST · GAME LAUNCHES AT ZERO' : 'WAITING FOR HOST TO LAUNCH...';
}

// ═══════════════════════════════════════════
// ONLINE GAME STATE SYNC
// ═══════════════════════════════════════════
let netStateInterval = null;

function handlePlayerState(data) {
  if (data.id === MY_ID) return;
  const ent = entities.find(e => e.netId === data.id);
  if (!ent || !ent.alive) return;
  // Smooth remote positions
  ent._nx = data.x; ent._ny = data.y;
  ent.turretAngle = data.ta;
  ent.hp = data.hp;
  ent.alive = data.alive;
  if (!data.alive && ent.alive) killTank(ent, null);
}

function handleGameEvent(data) {
  if (data.type === 'shoot' && data.id !== MY_ID) {
    const ent = entities.find(e => e.netId === data.id);
    if (ent && ent.alive) {
      // Spawn their bullet locally
      spawnRemoteBullet(ent, data.angle);
    }
  }
  if (data.type === 'ability' && data.id !== MY_ID) {
    const ent = entities.find(e => e.netId === data.id);
    if (ent && ent.alive) useAbility(ent);
  }
}

function spawnRemoteBullet(tank, angle) {
  const bx = tank.x + Math.cos(angle)*(tank.radius+15);
  const by = tank.y + Math.sin(angle)*(tank.radius+15);
  bullets.push({x:bx,y:by,vx:Math.cos(angle)*tank.bulletSpeed,vy:Math.sin(angle)*tank.bulletSpeed,owner:tank,life:tank.bulletLife,r:tank.className==='HEAVY'?7:tank.className==='SNIPER'?3:4,damage:tank.damage,pierce:tank.pierce,split:tank.split,hits:0,remote:true});
}

function broadcastState() {
  if (!onlineMode || !mqttConnected || !player || !player.alive) return;
  mqttPublish(mqttTopic(lobbyCode,'state'), {
    id: MY_ID, x: Math.round(player.x), y: Math.round(player.y),
    ta: player.turretAngle, hp: Math.round(player.hp), alive: player.alive
  });
}

function broadcastShoot(angle) {
  if (!onlineMode || !mqttConnected) return;
  mqttPublish(mqttTopic(lobbyCode,'event'), {type:'shoot', id:MY_ID, angle});
}

function broadcastAbility() {
  if (!onlineMode || !mqttConnected) return;
  mqttPublish(mqttTopic(lobbyCode,'event'), {type:'ability', id:MY_ID});
}

// ═══════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════
let gameMode, gameRunning=false;
let player, entities=[], bullets=[], particles=[], pickups=[];
let camera={x:0,y:0};
let mouseWorld={x:0,y:0}, mouseScreen={x:W/2,y:H/2};
let keys={}, mouseDown=false;
let zoneRadius, zoneCenter, zoneTargetRadius, zoneShrinkStart;
const zoneShrinkDelay=18000;
let trees=[], rocks=[], killFeedEntries=[];
let selectedClass='WARRIOR';
let gameStartTime, sessionKills=0, sessionXP=0;

// ═══════════════════════════════════════════
// MENU CROSSHAIR
// ═══════════════════════════════════════════
const menuCvs = document.getElementById('menuCvs');
const mxc = menuCvs.getContext('2d');
menuCvs.width=W; menuCvs.height=H;
let menuMouse={x:W/2,y:H/2}, menuFlash=0;
function drawMenuCrosshair() {
  mxc.clearRect(0,0,W,H);
  const x=menuMouse.x, y=menuMouse.y, sz=16, gap=6;
  mxc.save();
  if (menuFlash>0) { mxc.shadowColor='#fff'; mxc.shadowBlur=14; }
  mxc.strokeStyle='#fff'; mxc.lineWidth=menuFlash>0?2.5:1.5; mxc.globalAlpha=menuFlash>0?1:0.65;
  mxc.beginPath();
  mxc.moveTo(x-sz-gap,y); mxc.lineTo(x-gap,y);
  mxc.moveTo(x+gap,y);    mxc.lineTo(x+sz+gap,y);
  mxc.moveTo(x,y-sz-gap); mxc.lineTo(x,y-gap);
  mxc.moveTo(x,y+gap);    mxc.lineTo(x,y+sz+gap);
  mxc.stroke();
  mxc.beginPath(); mxc.arc(x,y,menuFlash>0?2.5:1.5,0,Math.PI*2); mxc.fillStyle='#fff'; mxc.fill();
  mxc.restore();
  if (menuFlash>0) menuFlash--;
}
function menuLoop() {
  if (!gameRunning) { drawMenuCrosshair(); requestAnimationFrame(menuLoop); }
}
requestAnimationFrame(menuLoop);
window.addEventListener('mousemove', e => { menuMouse.x=e.clientX; menuMouse.y=e.clientY; });
document.addEventListener('mousedown', e => {
  if (gameRunning) return;
  if (e.button===0 && e.target.tagName!=='BUTTON' && e.target.tagName!=='INPUT' && !e.target.closest('.classCard')) {
    playShot(); menuFlash=8;
  }
});

// ═══════════════════════════════════════════
// SCREEN FUNCTIONS
// ═══════════════════════════════════════════
function showMenu() {
  gameRunning=false; onlineMode=false;
  if (netStateInterval) { clearInterval(netStateInterval); netStateInterval=null; }
  ['classScreen','onlineScreen','lobbyScreen','deathScreen','winScreen'].forEach(id=>{
    const el=document.getElementById(id); if(el) el.style.display='none';
  });
  document.getElementById('menu').style.display='flex';
  updateMenuRankCard();
  document.getElementById('statsRow').textContent=`${pd.games} GAMES  ·  ${pd.kills} KILLS  ·  ${pd.wins} WINS`;
}

function updateMenuRankCard() {
  const ri = getRankInfo(pd.rp);
  const label = document.getElementById('rankTierLabel');
  label.textContent = ri.label;
  label.style.color = ri.color;
  document.getElementById('rankRpLabel').textContent = `${pd.rp} RP  (PEAK: ${pd.peakRp} RP)`;
  const pct = ri.isMaster ? 100 : Math.min(100, (ri.rpInDiv / ri.rpPerDiv) * 100);
  document.getElementById('rankBarFill').style.width = pct + '%';
  document.getElementById('rankBarFill').style.background = ri.color;
  if (ri.isMaster) {
    document.getElementById('rankBarSub').textContent = `MASTER — ${pd.rp} RP TOTAL`;
  } else {
    document.getElementById('rankBarSub').textContent = `${ri.rpInDiv} / ${ri.rpPerDiv} RP TO NEXT DIVISION`;
  }
}

function renderRpResult(elId, placement, kills, won) {
  const el = document.getElementById(elId);
  if (!el) return;
  const rp = calcRpChange(placement, kills);
  const result = applyRpChange(rp.total);
  pd.games++; pd.kills += kills; if (won) pd.wins++;
  saveData();
  const riAfter = getRankInfo(result.after);
  const riBefore = getRankInfo(result.before);
  const promoted = riAfter.label !== riBefore.label && result.after > result.before;
  const demoted  = riAfter.label !== riBefore.label && result.after < result.before;
  const sign = rp.total >= 0 ? '+' : '';
  const pct = riAfter.isMaster ? 100 : Math.min(100, (riAfter.rpInDiv / riAfter.rpPerDiv) * 100);
  el.innerHTML = `
    <div class="rpTitle">RANKED RESULT</div>
    <div class="rpRows" style="font-size:11px;letter-spacing:2px;color:#555;line-height:2;">
      PLACEMENT: #${placement} &nbsp;·&nbsp; KILLS: ${kills}<br>
      BASE: ${rp.base >= 0 ? '+' : ''}${rp.base} RP &nbsp;&nbsp; KILLS: +${rp.killBonus} RP
    </div>
    <div class="rpChange ${rp.total >= 0 ? 'up' : 'down'}">${sign}${rp.total} RP</div>
    ${promoted ? `<div style="color:#fff;font-size:11px;letter-spacing:3px;margin-top:6px;">▲ PROMOTED TO ${riAfter.label}!</div>` : ''}
    ${demoted  ? `<div style="color:#555;font-size:11px;letter-spacing:3px;margin-top:6px;">▼ DEMOTED TO ${riAfter.label}</div>` : ''}
    <div class="rpNew" style="color:${riAfter.color}">${riAfter.label} — ${result.after} RP</div>
    <div class="rpBarWrap"><div class="rpBarFill" id="rpAnimBar" style="width:0%;background:${riAfter.color}"></div></div>
  `;
  setTimeout(() => {
    const bar = document.getElementById('rpAnimBar');
    if (bar) bar.style.width = pct + '%';
  }, 100);
}

function showClassSelect(mode) {
  pendingMode=mode;
  ['menu','onlineScreen','lobbyScreen'].forEach(id=>{ const e=document.getElementById(id); if(e) e.style.display='none'; });
  document.getElementById('classScreen').style.display='flex';
  buildClassGrid();
}

function goBackFromClass() {
  document.getElementById('classScreen').style.display='none';
  if (pendingMode && pendingMode.startsWith('online')) {
    document.getElementById('onlineScreen').style.display='flex';
  } else {
    showMenu();
  }
}

function confirmClass() {
  document.getElementById('classScreen').style.display='none';
  if (pendingMode==='bot') {
    startGame('bot', selectedClass);
  } else if (pendingMode==='online_create') {
    if (!mqttConnected) {
      // Fallback to bot if no connection
      startGame('bot', selectedClass);
      return;
    }
    createLobby(selectedClass);
  } else if (pendingMode && pendingMode.startsWith('online_join_')) {
    const code = pendingMode.split('_')[2];
    if (!mqttConnected) { showMenu(); return; }
    joinLobby(code, selectedClass);
  }
}

function quickRestart() {
  document.getElementById('deathScreen').style.display='none';
  document.getElementById('winScreen').style.display='none';
  if (onlineMode) showMenu(); else startGame(gameMode, selectedClass);
}

function buildClassGrid() {
  const grid=document.getElementById('classGrid'); grid.innerHTML='';
  for (const [key,cls] of Object.entries(CLASSES)) {
    const div=document.createElement('div');
    div.className='classCard'+(key===selectedClass?' selected':'');
    div.innerHTML=`<div class="cicon">${cls.icon}</div><div class="cname">${key}</div><div class="cstat">${Object.entries(cls.stats).map(([k,v])=>`${k}: ${v}`).join('<br>')}</div><div class="cbadge">▶ ${cls.ability}: ${cls.abilityDesc}</div>`;
    div.onclick=()=>{ selectedClass=key; document.querySelectorAll('.classCard').forEach(c=>c.classList.remove('selected')); div.classList.add('selected'); };
    grid.appendChild(div);
  }
}

// ═══════════════════════════════════════════
// GAME INIT
// ═══════════════════════════════════════════
function seededRand(seed) {
  let s=seed; return ()=>{ s=(s*16807+0)%2147483647; return (s-1)/2147483646; };
}

function generateMap(seed=0) {
  const rand=seededRand(seed||Math.floor(Math.random()*999999));
  trees=[]; rocks=[];
  for (let i=0;i<220;i++) trees.push({x:rand()*MAP,y:rand()*MAP,r:10+rand()*12});
  for (let i=0;i<90;i++)  rocks.push({x:rand()*MAP,y:rand()*MAP,w:18+rand()*36,h:14+rand()*28});
}

function spawnPos() {
  let x,y,t=0;
  do { x=300+Math.random()*(MAP-600); y=300+Math.random()*(MAP-600); t++; }
  while (t<30 && entities.some(e=>dist(e.x,e.y,x,y)<200));
  return {x,y};
}

function dist(x1,y1,x2,y2) { return Math.sqrt((x2-x1)**2+(y2-y1)**2); }

function createTank(x,y,isPlayer,id,clsName,netId) {
  const cls=CLASSES[clsName]||CLASSES.WARRIOR;
  return {x,y,id,netId:netId||null,angle:0,turretAngle:0,hp:cls.hp,maxHp:cls.hp,speed:cls.speed,damage:cls.damage,fireRate:cls.fireRate,bulletSpeed:cls.bulletSpeed,bulletLife:cls.bulletLife,radius:cls.radius,barrels:cls.barrels,className:clsName,classIcon:cls.icon,ability:cls.ability,abilityCooldown:cls.abilityCooldown,abilityLastUsed:0,regen:0,pierce:false,split:false,extraBarrel:false,isPlayer,isBot:!isPlayer,isRemote:false,alive:true,vx:0,vy:0,lastShot:0,kills:0,xp:0,level:1,xpToNext:xpForLevel(1),upgrades:[],aiState:'wander',aiTarget:null,aiMoveAngle:Math.random()*Math.PI*2,aiMoveTimer:0,name:isPlayer?'YOU':'BOT_'+Math.random().toString(36).slice(2,6).toUpperCase(),cloaked:false,shielded:false,_nx:null,_ny:null};
}

function startGame(mode, clsName) {
  gameMode=mode; gameRunning=true; onlineMode=false;
  entities=[]; bullets=[]; particles=[]; pickups=[]; killFeedEntries=[];
  sessionKills=0; sessionXP=0;
  zoneRadius=MAP*0.5; zoneTargetRadius=zoneRadius*0.55;
  zoneCenter={x:MAP/2,y:MAP/2};
  zoneShrinkStart=Date.now()+zoneShrinkDelay;
  gameStartTime=Date.now();
  generateMap();
  const pos=spawnPos();
  player=createTank(pos.x,pos.y,true,0,clsName,MY_ID);
  entities.push(player);
  const ck=Object.keys(CLASSES);
  for (let i=1;i<MAX_P;i++) { const p=spawnPos(); entities.push(createTank(p.x,p.y,false,i,ck[Math.floor(Math.random()*ck.length)])); }
  camera.x=player.x-W/2; camera.y=player.y-H/2;
  document.getElementById('upgradePanel').style.display='none';
  updateHUD();
  requestAnimationFrame(gameLoop);
}

function startOnlineGame(data) {
  // data = {players: [{id,name,className,isBot},...], mapSeed}
  gameMode='online'; gameRunning=true; onlineMode=true;
  entities=[]; bullets=[]; particles=[]; pickups=[]; killFeedEntries=[];
  sessionKills=0; sessionXP=0;
  zoneRadius=MAP*0.5; zoneTargetRadius=zoneRadius*0.55;
  zoneCenter={x:MAP/2,y:MAP/2};
  zoneShrinkStart=Date.now()+zoneShrinkDelay;
  gameStartTime=Date.now();
  generateMap(data.mapSeed); // seeded so all players get same map

  let myIdx=data.players.findIndex(p=>p.id===MY_ID);
  if (myIdx===-1) myIdx=0;

  data.players.forEach((p, i) => {
    const pos=spawnPos();
    const isMe = p.id===MY_ID;
    const tank = createTank(pos.x, pos.y, isMe, i, p.className, p.id);
    tank.name = isMe ? 'YOU' : p.name;
    tank.isBot = p.isBot;
    tank.isRemote = !isMe && !p.isBot;
    if (isMe) player=tank;
    entities.push(tank);
  });

  camera.x=player.x-W/2; camera.y=player.y-H/2;
  document.getElementById('upgradePanel').style.display='none';

  // Subscribe to game state channels
  mqttSubscribe(mqttTopic(lobbyCode,'state'));
  mqttSubscribe(mqttTopic(lobbyCode,'event'));

  // Broadcast own position every 50ms
  netStateInterval = setInterval(broadcastState, 50);

  updateHUD();
  requestAnimationFrame(gameLoop);
}

// ═══════════════════════════════════════════
// UPGRADES
// ═══════════════════════════════════════════
function offerUpgrades() {
  gameRunning=false;
  const panel=document.getElementById('upgradePanel'); panel.style.display='block';
  const btns=document.getElementById('upgradeBtns'); btns.innerHTML='';
  const pool=[...UPGRADES].filter(u=>!(u.id==='pierce'&&player.pierce)&&!(u.id==='split'&&player.split)&&!(u.id==='multi'&&player.extraBarrel));
  const choices=[];
  while (choices.length<3&&pool.length>0) choices.push(pool.splice(Math.floor(Math.random()*pool.length),1)[0]);
  choices.forEach(u=>{
    const btn=document.createElement('button'); btn.className='upBtn';
    const times=player.upgrades.filter(x=>x===u.id).length;
    btn.innerHTML=`<div class="upName">${u.name}</div><div class="upDesc">${u.desc.replace(/\n/g,'<br>')}</div><div class="upLvl">Taken: ${times}×</div>`;
    btn.onclick=()=>{ u.apply(player); player.upgrades.push(u.id); showXPFloat(`▲ ${u.name}`,player); panel.style.display='none'; gameRunning=true; requestAnimationFrame(gameLoop); };
    btns.appendChild(btn);
  });
}

function giveXP(tank, amount) {
  if (!tank.isPlayer) return;
  tank.xp+=amount;
  while (tank.xp>=tank.xpToNext) { tank.xp-=tank.xpToNext; tank.level++; tank.xpToNext=xpForLevel(tank.level); offerUpgrades(); return; }
  updateHUD();
}

function showXPFloat(txt, tank) {
  const sx=tank.x-camera.x, sy=tank.y-camera.y-30;
  const div=document.createElement('div'); div.className='xpFloat'; div.textContent=txt;
  div.style.left=sx+'px'; div.style.top=sy+'px';
  document.getElementById('gc').appendChild(div);
  setTimeout(()=>div.remove(),950);
}

// ═══════════════════════════════════════════
// FIRING
// ═══════════════════════════════════════════
function fireBullet(tank) {
  const now=Date.now();
  if (now-tank.lastShot<tank.fireRate) return false;
  tank.lastShot=now;
  if (tank.isPlayer) { playShot(tank.className==='HEAVY'?0.58:tank.className==='SNIPER'?1.6:1); }
  let angles=[tank.turretAngle];
  if (tank.barrels===2) angles=[tank.turretAngle-0.1,tank.turretAngle+0.1];
  if (tank.extraBarrel) angles.push(tank.turretAngle+Math.PI/8*(Math.random()>.5?1:-1));
  for (const a of angles) {
    const bx=tank.x+Math.cos(a)*(tank.radius+15), by=tank.y+Math.sin(a)*(tank.radius+15);
    bullets.push({x:bx,y:by,vx:Math.cos(a)*tank.bulletSpeed,vy:Math.sin(a)*tank.bulletSpeed,owner:tank,life:tank.bulletLife,r:tank.className==='HEAVY'?7:tank.className==='SNIPER'?3:4,damage:tank.damage,pierce:tank.pierce,split:tank.split,hits:0,remote:false});
    for (let i=0;i<5;i++) particles.push({x:bx,y:by,vx:(Math.random()-.5)*4+Math.cos(a)*3,vy:(Math.random()-.5)*4+Math.sin(a)*3,life:12,maxLife:12,r:3+Math.random()*3});
  }
  return true;
}

function fireSplit(b) {
  for (let i=0;i<3;i++) {
    const a=Math.atan2(b.vy,b.vx)+(i-1)*0.45, sp=Math.hypot(b.vx,b.vy)*0.7;
    bullets.push({x:b.x,y:b.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,owner:b.owner,life:70,r:3,damage:b.damage*0.5,pierce:false,split:false,hits:0,remote:false});
  }
}

// ═══════════════════════════════════════════
// ABILITY
// ═══════════════════════════════════════════
function useAbility(tank) {
  const now=Date.now();
  if (now-tank.abilityLastUsed<tank.abilityCooldown) return;
  tank.abilityLastUsed=now;
  if (tank.isPlayer && onlineMode) broadcastAbility();
  if (tank.ability==='DASH') { const sp=tank.speed*8; tank.x=Math.max(tank.radius,Math.min(MAP-tank.radius,tank.x+Math.cos(tank.angle)*sp)); tank.y=Math.max(tank.radius,Math.min(MAP-tank.radius,tank.y+Math.sin(tank.angle)*sp)); for (let i=0;i<14;i++) particles.push({x:tank.x,y:tank.y,vx:(Math.random()-.5)*7,vy:(Math.random()-.5)*7,life:18,maxLife:18,r:4+Math.random()*4}); }
  if (tank.ability==='SHIELD') { tank.shielded=true; setTimeout(()=>{tank.shielded=false;},2000); }
  if (tank.ability==='SLAM') { for (const e of entities) { if(e===tank||!e.alive) continue; const d=dist(tank.x,tank.y,e.x,e.y); if(d<190){e.hp-=tank.damage*1.6;spawnExplosion(e.x,e.y,10);if(e.hp<=0)killTank(e,tank);} } for(let i=0;i<28;i++){const a=Math.random()*Math.PI*2;particles.push({x:tank.x,y:tank.y,vx:Math.cos(a)*7,vy:Math.sin(a)*7,life:28,maxLife:28,r:5+Math.random()*5});} }
  if (tank.ability==='CLOAK') { tank.cloaked=true; setTimeout(()=>{tank.cloaked=false;},3500); }
  if (tank.ability==='BURST') { for(let i=0;i<6;i++) setTimeout(()=>{ if(tank.alive){const tmp=tank.lastShot;tank.lastShot=0;fireBullet(tank);tank.lastShot=Date.now();}},i*55); }
}

// ═══════════════════════════════════════════
// AI
// ═══════════════════════════════════════════
function updateAI(tank, dt) {
  if (!tank.alive) return;
  let nearest=null, nd=Infinity;
  for (const e of entities) { if(e===tank||!e.alive) continue; const d=dist(tank.x,tank.y,e.x,e.y); if(d<nd){nd=d;nearest=e;} }
  const dz=dist(tank.x,tank.y,zoneCenter.x,zoneCenter.y);
  if (dz>zoneRadius-80) { tank.aiMoveAngle=Math.atan2(zoneCenter.y-tank.y,zoneCenter.x-tank.x); tank.aiState='wander'; }
  else if (nearest&&nd<680) { tank.aiState='chase'; tank.aiTarget=nearest; }
  else { tank.aiState='wander'; tank.aiMoveTimer-=dt; if(tank.aiMoveTimer<=0){tank.aiMoveTimer=1800+Math.random()*3000;tank.aiMoveAngle=Math.random()*Math.PI*2;} }
  if (tank.aiState==='chase'&&tank.aiTarget) { const ang=Math.atan2(tank.aiTarget.y-tank.y,tank.aiTarget.x-tank.x); tank.aiMoveAngle=ang; tank.turretAngle=ang; if(nd<580)fireBullet(tank); if(Math.random()<0.003)useAbility(tank); }
  else tank.turretAngle=tank.aiMoveAngle;
  tank.angle=tank.aiMoveAngle; tank.vx=Math.cos(tank.aiMoveAngle)*tank.speed*0.7; tank.vy=Math.sin(tank.aiMoveAngle)*tank.speed*0.7;
}

function updatePlayer() {
  if (!player||!player.alive) return;
  let dx=0,dy=0;
  if(keys['w']||keys['arrowup'])dy--; if(keys['s']||keys['arrowdown'])dy++;
  if(keys['a']||keys['arrowleft'])dx--; if(keys['d']||keys['arrowright'])dx++;
  if(dx||dy){const l=Math.hypot(dx,dy);player.angle=Math.atan2(dy/l,dx/l);player.vx=(dx/l)*player.speed;player.vy=(dy/l)*player.speed;}
  else{player.vx=0;player.vy=0;}
  player.turretAngle=Math.atan2(mouseWorld.y-player.y,mouseWorld.x-player.x);
}

// ═══════════════════════════════════════════
// PICKUPS
// ═══════════════════════════════════════════
function spawnPickup(x,y){if(Math.random()>0.45)return;pickups.push({x,y,type:'hp',value:30,r:10,pulse:0});}
function updatePickups(){for(let i=pickups.length-1;i>=0;i--){const pk=pickups[i];pk.pulse+=0.06;if(dist(pk.x,pk.y,player.x,player.y)<pk.r+player.radius){player.hp=Math.min(player.maxHp,player.hp+pk.value);showXPFloat('+'+pk.value+' HP',player);pickups.splice(i,1);}}}

// ═══════════════════════════════════════════
// KILL & END GAME
// ═══════════════════════════════════════════
function killTank(tank, killer) {
  if (!tank.alive) return;
  tank.alive=false;
  spawnExplosion(tank.x,tank.y,22); spawnExplosion(tank.x,tank.y,14);
  spawnPickup(tank.x,tank.y);
  const kn=killer?(killer.isPlayer?'YOU':killer.name):'ZONE';
  addKF(`${kn} → ${tank.name} [${tank.className}]`);
  if (killer&&killer.isPlayer) {
    killer.kills++;
    const xg=50+tank.level*15; giveXP(killer,xg); showXPFloat(`+${xg} XP`,killer); sessionKills++;
  }
  if (tank.isPlayer) {
    if (netStateInterval) { clearInterval(netStateInterval); netStateInterval=null; }
    const aliveNow = entities.filter(e=>e.alive).length;
    const placement = aliveNow + 1; // player just died, so their placement is survivors+1
    const elapsed = Math.floor((Date.now()-gameStartTime)/1000);
    setTimeout(()=>{
      document.getElementById('endStats').innerHTML=
        `PLACEMENT: #${placement} / ${MAX_P}  ·  TIME: ${elapsed}s<br>KILLS: ${sessionKills}  ·  CLASS: ${player.className} LV${player.level}${onlineMode?'<br><span style="color:#555">LOBBY: '+lobbyCode+'</span>':''}`;
      renderRpResult('rpResult', placement, sessionKills, false);
      document.getElementById('deathScreen').style.display='flex';
    }, 1000);
    gameRunning=false; return;
  }
  const alive=entities.filter(e=>e.alive);
  if (alive.length===1&&alive[0].isPlayer) {
    if (netStateInterval) { clearInterval(netStateInterval); netStateInterval=null; }
    const elapsed = Math.floor((Date.now()-gameStartTime)/1000);
    setTimeout(()=>{
      document.getElementById('endStats2').innerHTML=
        `PLACEMENT: #1 / ${MAX_P}  ·  TIME: ${elapsed}s<br>KILLS: ${sessionKills}  ·  CLASS: ${player.className} LV${player.level}${onlineMode?'<br><span style="color:#555">LOBBY: '+lobbyCode+'</span>':''}`;
      renderRpResult('rpResult2', 1, sessionKills, true);
      document.getElementById('winScreen').style.display='flex';
    }, 500);
    gameRunning=false;
  }
}

function spawnExplosion(x,y,n=20){for(let i=0;i<n;i++){const a=Math.random()*Math.PI*2,sp=1+Math.random()*5;particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:25+Math.random()*25,maxLife:50,r:3+Math.random()*6});}}
function addKF(msg){const d=document.createElement('div');d.className='ke';d.textContent=msg;document.getElementById('kf').prepend(d);killFeedEntries.push(d);setTimeout(()=>{d.style.opacity='0';setTimeout(()=>d.remove(),900);},3500);if(killFeedEntries.length>6)killFeedEntries.shift().remove();}

// ═══════════════════════════════════════════
// HUD
// ═══════════════════════════════════════════
function updateHUD() {
  if (!player) return;
  document.getElementById('hpFill').style.width=Math.max(0,player.hp/player.maxHp*100)+'%';
  document.getElementById('xpFill').style.width=(player.xp/player.xpToNext*100)+'%';
  document.getElementById('lvlLabel').textContent='LV '+player.level;
  document.getElementById('classTag').textContent=player.className+' '+player.classIcon+(onlineMode?' [ONLINE]':'');
  document.getElementById('aliveCount').textContent='■ '+entities.filter(e=>e.alive).length+' ALIVE';
  const ri=getRankInfo(pd.rp);
  const rb=document.getElementById('rankBadge');
  rb.textContent=ri.label+' · '+pd.rp+' RP';
  rb.style.color=ri.color;
  rb.style.borderColor=ri.color.replace(')',',0.3)').replace('rgb','rgba').replace('#','').length>6?ri.color:'#1e1e1e';
  const now=Date.now(), cdLeft=Math.max(0,player.abilityCooldown-(now-player.abilityLastUsed)), cdPct=1-cdLeft/player.abilityCooldown, pips=10, filled=Math.round(cdPct*pips);
  document.getElementById('ammoBar').innerHTML=`<span style="font-size:9px;letter-spacing:1px;color:#555;margin-right:5px;">${player.ability}</span>`+Array.from({length:pips},(_,i)=>`<div class="ammoPip${i<filled?'':' empty'}"></div>`).join('');
  document.getElementById('zoneInfo').textContent=Date.now()>zoneShrinkStart?'⚠ ZONE CLOSING':'';
}

// ═══════════════════════════════════════════
// GAME LOOP
// ═══════════════════════════════════════════
let lastFrame=0;
function gameLoop(ts) {
  if (!gameRunning) return;
  const dt=Math.min(ts-lastFrame,50); lastFrame=ts;
  update(dt); render();
  requestAnimationFrame(gameLoop);
}

function update(dt) {
  updatePlayer();
  const now=Date.now();
  // Zone
  if (now>zoneShrinkStart) {
    zoneRadius+=(zoneTargetRadius-zoneRadius)*0.0015;
    if (Math.abs(zoneRadius-zoneTargetRadius)<5) { zoneShrinkStart=now+zoneShrinkDelay; zoneTargetRadius=Math.max(80,zoneRadius*0.62); }
  }
  // Tanks
  for (const tank of entities) {
    if (!tank.alive) continue;
    if (tank.isRemote) {
      // Smoothly interpolate remote player positions
      if (tank._nx!==null) { tank.x+=(tank._nx-tank.x)*0.25; tank.y+=(tank._ny-tank.y)*0.25; }
      continue;
    }
    if (!tank.isPlayer) updateAI(tank,dt);
    if (tank.regen&&tank.hp<tank.maxHp) tank.hp=Math.min(tank.maxHp,tank.hp+tank.regen);
    tank.x=Math.max(tank.radius,Math.min(MAP-tank.radius,tank.x+tank.vx));
    tank.y=Math.max(tank.radius,Math.min(MAP-tank.radius,tank.y+tank.vy));
    const dz=dist(tank.x,tank.y,zoneCenter.x,zoneCenter.y);
    if (dz>zoneRadius) { tank.hp-=0.18; if(tank.hp<=0) killTank(tank,null); }
  }
  // Bullets
  for (let i=bullets.length-1;i>=0;i--) {
    const b=bullets[i]; b.x+=b.vx; b.y+=b.vy; b.life--;
    if (b.x<0||b.x>MAP||b.y<0||b.y>MAP||b.life<=0) { bullets.splice(i,1); continue; }
    let gone=false;
    for (const r of rocks) { if(b.x>r.x&&b.x<r.x+r.w&&b.y>r.y&&b.y<r.y+r.h){spawnExplosion(b.x,b.y,5);bullets.splice(i,1);gone=true;break;} }
    if (gone) continue;
    // Remote bullets only damage local entities (bots + player)
    for (const tank of entities) {
      if (!tank.alive||tank===b.owner||tank.shielded) continue;
      if (tank.isRemote) continue; // remote players handle their own damage
      if (dist(b.x,b.y,tank.x,tank.y)<tank.radius) {
        tank.hp-=b.damage; spawnExplosion(b.x,b.y,6);
        if (b.split&&b.hits===0) fireSplit(b);
        b.hits++;
        if (!b.pierce||b.hits>1) { bullets.splice(i,1); gone=true; }
        if (tank.hp<=0) killTank(tank,b.owner);
        break;
      }
    }
    if (gone) continue;
  }
  for (let i=particles.length-1;i>=0;i--) { const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vx*=0.88;p.vy*=0.88;p.life--;if(p.life<=0)particles.splice(i,1); }
  updatePickups();
  camera.x+=(player.x-W/2-camera.x)*0.1; camera.y+=(player.y-H/2-camera.y)*0.1;
  updateHUD();
}

// ═══════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════
function render() {
  ctx.clearRect(0,0,W,H);
  ctx.save(); ctx.translate(-camera.x,-camera.y);
  ctx.fillStyle='#0d0d0d'; ctx.fillRect(0,0,MAP,MAP);
  ctx.strokeStyle='#141414'; ctx.lineWidth=1;
  for(let x=0;x<=MAP;x+=100){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,MAP);ctx.stroke();}
  for(let y=0;y<=MAP;y+=100){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(MAP,y);ctx.stroke();}
  ctx.strokeStyle='#fff'; ctx.lineWidth=3; ctx.strokeRect(0,0,MAP,MAP);
  ctx.save(); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.beginPath(); ctx.rect(0,0,MAP,MAP); ctx.arc(zoneCenter.x,zoneCenter.y,zoneRadius,0,Math.PI*2,true); ctx.fill(); ctx.restore();
  ctx.beginPath(); ctx.arc(zoneCenter.x,zoneCenter.y,zoneRadius,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=2; ctx.stroke();
  for(const t of trees){ctx.beginPath();ctx.arc(t.x,t.y,t.r,0,Math.PI*2);ctx.fillStyle='#161616';ctx.fill();ctx.strokeStyle='#222';ctx.lineWidth=1;ctx.stroke();ctx.beginPath();ctx.arc(t.x,t.y,t.r*0.4,0,Math.PI*2);ctx.fillStyle='#1d1d1d';ctx.fill();}
  for(const r of rocks){ctx.fillStyle='#171717';ctx.fillRect(r.x,r.y,r.w,r.h);ctx.strokeStyle='#252525';ctx.lineWidth=1;ctx.strokeRect(r.x,r.y,r.w,r.h);}
  for(const pk of pickups){const s=1+Math.sin(pk.pulse)*0.12;ctx.save();ctx.translate(pk.x,pk.y);ctx.scale(s,s);ctx.strokeStyle='#fff';ctx.lineWidth=1.5;ctx.strokeRect(-pk.r,-pk.r,pk.r*2,pk.r*2);ctx.font='bold 9px Courier New';ctx.fillStyle='#fff';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText('+HP',0,0);ctx.restore();}
  for(const p of particles){const a=p.life/p.maxLife;ctx.beginPath();ctx.arc(p.x,p.y,p.r*a,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${a})`;ctx.fill();}
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fillStyle='#fff';ctx.fill();ctx.beginPath();ctx.moveTo(b.x,b.y);ctx.lineTo(b.x-b.vx*5,b.y-b.vy*5);ctx.strokeStyle='rgba(255,255,255,0.25)';ctx.lineWidth=2;ctx.stroke();}
  for(const tank of entities){if(!tank.alive||(tank.cloaked&&!tank.isPlayer))continue;drawTank(ctx,tank);}
  ctx.restore();
  drawCrosshair();
  renderMinimap();
}

function drawTank(c,tank) {
  c.save(); c.translate(tank.x,tank.y); const r=tank.radius;
  if(tank.shielded){c.beginPath();c.arc(0,0,r+9,0,Math.PI*2);c.strokeStyle='rgba(255,255,255,0.55)';c.lineWidth=3;c.stroke();}
  c.globalAlpha=tank.cloaked?0.3:1;
  c.beginPath();c.arc(3,3,r,0,Math.PI*2);c.fillStyle='rgba(0,0,0,0.35)';c.fill();
  // Remote players get a slightly different tint
  const bodyColor = tank.isPlayer?'#fff':tank.isRemote?'#e0e0e0':'#b8b8b8';
  c.beginPath();c.arc(0,0,r,0,Math.PI*2);c.fillStyle=bodyColor;c.fill();c.lineWidth=2.5;c.strokeStyle='#000';c.stroke();
  c.font=`${Math.round(r*0.85)}px Courier New`;c.fillStyle='#000';c.textAlign='center';c.textBaseline='middle';c.fillText(tank.classIcon,0,0);
  c.save();c.rotate(tank.turretAngle);
  const blen=tank.className==='SNIPER'?r+24:tank.className==='HEAVY'?r+11:r+13;
  const bw=tank.className==='HEAVY'?10:tank.className==='SNIPER'?4:7;
  c.fillStyle='#000';
  if(tank.barrels===2){c.fillRect(0,-bw*0.85,blen,bw*0.65);c.fillRect(0,bw*0.2,blen,bw*0.65);}
  else c.fillRect(0,-bw/2,blen,bw);
  c.beginPath();c.arc(0,0,r*0.56,0,Math.PI*2);c.fillStyle='#000';c.fill();
  c.restore();
  if(tank.isPlayer||tank.hp<tank.maxHp){const bw=r*2.5,bh=3,bx=-r*1.25,by=-r-11;c.fillStyle='#111';c.fillRect(bx,by,bw,bh);const pct=Math.max(0,tank.hp/tank.maxHp);c.fillStyle=pct>0.5?'#fff':pct>0.25?'#aaa':'#777';c.fillRect(bx,by,bw*pct,bh);}
  // Show name for remote players
  if (tank.isRemote) { c.font='8px Courier New'; c.fillStyle='#777'; c.textAlign='center'; c.fillText(tank.name, 0, -r-20); }
  else if(tank.level>1){c.font='8px Courier New';c.fillStyle='#666';c.textAlign='center';c.fillText('LV'+tank.level,0,-r-20);}
  c.globalAlpha=1; c.restore();
}

function drawCrosshair() {
  const x=mouseScreen.x, y=mouseScreen.y, sz=14, gap=5;
  ctx.strokeStyle='#fff'; ctx.lineWidth=1.5; ctx.shadowColor='#000'; ctx.shadowBlur=4;
  ctx.beginPath(); ctx.moveTo(x-sz-gap,y); ctx.lineTo(x-gap,y); ctx.moveTo(x+gap,y); ctx.lineTo(x+sz+gap,y); ctx.moveTo(x,y-sz-gap); ctx.lineTo(x,y-gap); ctx.moveTo(x,y+gap); ctx.lineTo(x,y+sz+gap); ctx.stroke();
  ctx.beginPath(); ctx.arc(x,y,1.5,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.shadowBlur=0;
  if (player&&player.alive) {
    const now=Date.now(), cdLeft=Math.max(0,player.abilityCooldown-(now-player.abilityLastUsed)), pct=1-cdLeft/player.abilityCooldown;
    ctx.beginPath(); ctx.arc(x,y,22,-Math.PI/2,-Math.PI/2+pct*Math.PI*2);
    ctx.strokeStyle=cdLeft===0?'rgba(255,255,255,0.85)':'rgba(255,255,255,0.25)'; ctx.lineWidth=1.5; ctx.stroke();
  }
}

function renderMinimap() {
  const sc=MINI/MAP; mctx.clearRect(0,0,MINI,MINI);
  mctx.fillStyle='rgba(0,0,0,0.9)'; mctx.fillRect(0,0,MINI,MINI);
  mctx.beginPath(); mctx.arc(zoneCenter.x*sc,zoneCenter.y*sc,zoneRadius*sc,0,Math.PI*2); mctx.strokeStyle='rgba(255,255,255,0.35)'; mctx.lineWidth=1; mctx.stroke();
  mctx.strokeStyle='rgba(255,255,255,0.18)'; mctx.lineWidth=1; mctx.strokeRect(camera.x*sc,camera.y*sc,W*sc,H*sc);
  for (const tank of entities) {
    if (!tank.alive||(tank.cloaked&&!tank.isPlayer)) continue;
    mctx.beginPath(); mctx.arc(tank.x*sc,tank.y*sc,tank.isPlayer?4:tank.isRemote?3:2.5,0,Math.PI*2);
    mctx.fillStyle=tank.isPlayer?'#fff':tank.isRemote?'#ccc':'#555'; mctx.fill();
  }
  mctx.strokeStyle='#333'; mctx.lineWidth=1; mctx.strokeRect(0,0,MINI,MINI);
}

// ═══════════════════════════════════════════
// INPUT
// ═══════════════════════════════════════════
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()]=true;
  if ((e.key==='1'||e.key===' ')&&player&&player.alive&&gameRunning) { e.preventDefault(); useAbility(player); }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()]=false; });
canvas.addEventListener('mousemove', e => { mouseScreen.x=e.clientX; mouseScreen.y=e.clientY; mouseWorld.x=e.clientX+camera.x; mouseWorld.y=e.clientY+camera.y; });
canvas.addEventListener('mousedown', e => {
  if (e.button===0) {
    mouseDown=true;
    if (player&&player.alive&&gameRunning) {
      const fired = fireBullet(player);
      if (fired && onlineMode) broadcastShoot(player.turretAngle);
    }
  }
});
canvas.addEventListener('mouseup', e => { if(e.button===0) mouseDown=false; });
setInterval(() => {
  if (mouseDown&&player&&player.alive&&gameRunning) {
    const fired = fireBullet(player);
    if (fired && onlineMode) broadcastShoot(player.turretAngle);
  }
}, 75);

// BOOT
showMenu();
</script>
</body>
</html>
